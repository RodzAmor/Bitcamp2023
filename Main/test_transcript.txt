OK, guys, are you doing to meet this? Very good to know.
Oh, hello. Can you hear me?
Yes, OK. So let's finish your packing. So let's try.
We saw hashing the technique we can store. By placing an array, we can store values in buckets where each of the entries of the tables become list.
Now what we're talking about is how those hashing and other relate.
And here's the message when you implement the class, if you override the equals method,
you need to provide an appropriate hash coordinated and you say, What if I don't do it?
Then classes that rely on hashing will fail.
That's the message. That's it. And you say we never did that in one three one one three one, we were able to override the equals.
We never worry about the hash code. True, but you never use classes that rely on hashing.
That's why you were able to get away with it. But from now on, and this is not a one three two thing, this is a Java programmer thing.
When you define a class, if you override the equals method,
you need to make sure you provide the appropriate hash code method and you will say what those appropriate mean.
It means that the Java hash code contract is satisfied.
So when you have a class, the hash code contract must always be satisfied.
And what does the contract says? It says the following. The values OK?
The hash code should return when two objects are considered equals must be the same.
So if I have two objects, OK, I have an instance of the banner class and I have a second instance.
If I do, a dot equals B. If the equals method that I provided because I over wrote the method,
if either the equals B returns true when I do a dot hash code and B the hash code, you must have the same value if not during trouble.
That's it. That's it. Does that make sense?
Guys, I mean, get this. That's what it says. Now, some of you will begin to ask Lou, what if I have two hash codes that are the same?
Does that mean the objects are the same? No. Is that incorrect?
No, no. This Howie's phrase, if two objects are equals according to the equals method, they're hash code must be the same.
That's good. Now Ethiopia has the same high school.
Do they need to be the same? Do it to hash codes are different.
Are the objects suppose to be a different?
Guys, yeah. They had to be different because they hash code these unique per object, but two objects that can have the same hash code.
So the most simple way to implement the hash code is that for the class, you always return the same value and the hash code method.
If you are in a hurry and you say, Well, I just want to satisfy that you have a hash code contract.
Just make sure that the method returns an integer .
That's it. Said every object will have the same high school.
Are you satisfied that you have a hash code contract? In that case, guys, it will be the worse.
Why? Because remember, this hash code is used for hashing. And what do you do when hashing?
You want to find a bucket? So if you're always returning the same value, you're mapping everything to the same table entry.
You're going to have collisions all the time, all the time. But it's legal to give you something correct.
It's just that the performance that you want from hashing that is big of one will not exist.
How we doing, guys? OK? Look at your friend and say, Should I hash you go and explain what I used to go for it?
We need to write classes that satisfy the Java hash code content.
Now this thing here, what basically is trying to tell you is this the hash code relies on the fields of a class, the instance variables.
So in the class that we were taking a look at where we were, you know, defining for a person,
if we go to the hashing example here, we had a person class and the person class was defining a hash code.
It was saying, Hey, here's a possible Haskell .
Does the class satisfy the yellow hash code kontra? Well, look at the classmate.
The closest to object said equals if they have the same name. Well, yeah, I will get the same value, but this will cost a lot of collisions.
We want to do better. We would like to be able to distribute. OK.
Ideally, every object to have its own hash anybody.
In a perfect world, every object will have its own number.
You know, that's tough. Are you with me? So what you want to do, though, is to use data of the object.
What kind of data? Whatever the equals method relies on.
So the hash code should use the data that the equals method relies on, so the equals method relies on the name and the address you better use.
OK. Those two in the hash code. But if you if you read course method relies on the name and the address.
OK. And you only use probably the address, you may get in trouble.
OK. The point is that you want to make sure that if the equal Smith says that these two objects are the same,
you want the hash code to return the same value.
So when you have this class here name, what can you use to generate hash Caldwell?
Anything that could generate different values for each object?
So if let's suppose in this territory, OK, the names of people are unique.
You cannot every person. The first letter of every name is different, then that, you know, could be a good hash function.
Unfortunately, I'm assuming that how many names are there in this location? If the first letter is unique.
OK. No one two people can have the same first letter, so how many names can I have then, huh?
Twenty six. Right? Well, not really, because you're twenty six, so twenty six, so that's not good.
OK. But he's better than your returning an integer.
Now you could say, if I know that usually the first two characters are different, then you can use name chart at one.
Or you can add them all. So there is some magic, not a magic,
but there is some examination of the data that you have in order to determine whether the we have the correct Haskell guys in this problem.
Look at the description. What does it represent? Represents the A.D.?
Are these unique? They are. So what is the best hatch code for this problem?
Returning Ivy. You see that we guarantee that every object has its own ID.
And if two objects are equal, you will return. And that's the best. So here, that's easy.
You see, the data that we have makes it easy. If we don't have an idea, maybe we have here like a h.
Maybe we can make a combination of the two in order to produce something that is unique because in name and the age combined,
probably that's harder to get multiple instances of them across many people.
Guys are my beating a dead horse here. Does that make sense what I'm talking about?
Good. Now I want you to keep that in mind. This is very important to go about here.
I want to then refer to the following. You see all of this.
This is just to try to pinpoint a little problem. All of this is trying to tell you this.
Use this and don't use this. That's all that this is trying to tell you.
And you will say, I don't get it. Well, let me just explain this, OK?
All of this is the follow up when you have a table that has this science and is in the right.
This size in an X is what the hash code method returns.
That's what the hash code meant, that the Java Haskell method returns, guys,
when we look at the definition of the hash code, when does it returns an integer correct?
Can an integer be negative? Yes, this implementation of the hash code is legit.
This is valid, this is valid.
It does not need to be a positive value. It has to be an integer.
Everybody with, you know, so because that is the case when you are saying, give me a hash code, the hash code is not the hash index.
This is the table. Are you with the guys? How do we use a hash index?
This is how we use the hash index. Let me show you how we use the hash index.
This is how we used the hash code. Hey, give me your hash code.
Let's do a modulus. OK. Of that?
Oh, my God. Tell me something here. Did I drop the ball there?
Yes, that's fine. I'll took to the election manager for now.
Bear with me this, OK?
We'll tell you, OK, we should go correct. That will give you a value between zero and minus one.
Now the problem is what is the hash code is negative.
What is negative one modulus for, is it positive or negative?
Negative? Can we have a negative index? We can't.
So what does that mean that when you use hash code, OK, you need to take that into account?
OK, now. So how can you deal with that?
OK, well, you will say, well, I just basically have to know I'm OK on the above code,
I'm OK, so I call the hash code and I have to do the absolute value of it is in the right.
And then I do the modules and everything would be happy with how would doing this?
Yeah, go ahead. Would you get a negative output? Oh, the hash function can do that if once it finds that that's a good way to distribute the values.
So the point is that it's a possibility. OK, how we doing, guys?
I know it's a little bit complex, but on Trenton for you. And that's it.
You say, Well, I'm happy. Do math.
You know this is the hash code, do they absolute value Model S. I will have a positive value of zero and then I can index good.
Yes, my son. What is the purpose of the hash? You know, the hash indexes, the location in the table will you will put the value, that's the hash.
So if this is, for example, a banana object, give me your hash code.
I will find the absolute value I will do modulo. Send the modulus maps to one of this.
That's where you go. Make sense and you're like, Hey, happy with this little little, little little problem.
And it's just a programing language. I paid my taxes last year.
OK, go away. So here's the problem.
And let me show you the problem with this example. Absent.
People, I want you to take a careful look at this example.
Look at this. What is the maximum value that we have in Java?
This what is the minimum value? This is a little bit more in terms of magnitude, you would think we can represent more negative values than positives.
This is just a computer thing. It's not a Java thing. OK. Oh, you look fine.
No problem. What is the absolute value of the minimum value?
Do you see that, guys? The absolute value of the minimum value, which is this one is a negative number, is that right?
That's not right. And there's nothing wrong there.
The issues that you have a limit, there's so much you can present in the computer.
Are you living? So you reach the limit. You cannot find the absolute value of the smallest possible value.
You can't. It's a computer thing. We can increase the number of beats, but we will keep the world just further down the road.
That's it. How we doing, guys, does that make sense?
Let me give you a look at your friend and say, what happened if you friends want to take part of the conversation there of the person as your friend?
Go. To do the right, everybody is OK, amigos questions, I think it is.
Look at this. This is something you can understand. Guys look at this and you say OK, but but.
OK, OK. That absolute value. OK, but now here's the second point.
If I do the modulus of the smallest value, that negative value modulus three.
Look at the result that I get into your minimum modulus three.
Negative two. When you do the modulus of a number, this sign of the result corresponds to the first argument minus three models.
Two is minus one minus three modulus minus two is minus one.
You say, why does the definition this operator is defined like this x minus y multiplied by x divided by way.
By definition, the summary of this is that the sign of X percent, which way is the sign of X all?
And now you said, so what? Well, if you have integer mean value modulo three, the result is negative.
Two because these values negative. Now.
What if I do the following the absolute value of this number, the minimum, what is it going to be positive or negative?
Guys, this is going to be negative is in the right.
When you do, Model three is going to be positive or negative negative.
So if you are using a hash code and the hash code for some reason returns this integer value when you do,
when you do matter wraps of that hash code value percentage three.
Is that going to give you a hash index that is positive or negative? You're a little bit lost, guys, a little bit.
OK. This is what I'm trying to say. Public void, static.
Give me Haskell, give me Haskell, guys.
Is it invalid to return integer?
The mean value as your hash code is, is invalid or invalid?
Is it valid or invalid, guys? That's a valid hash code.
Usually this goes. Discourse here is that valid or invalid public static void?
Oh, yeah, there you go.
If I were to say just give me a hash code value, these returning negatives that big, no, it's not OK, yes, I can implement the method.
OK, with this, this is fine. How would you use that?
Oh. How do we use the hash code where we say, well, the hash index that is the index in the table is going to be what get?
Give me give me hash code. They give me the integer.
How do I find the one position on a table of five of size five?
What do I do, guys modulus five, right?
That will give me zero or four. Would it if the value is negative?
What can you do to make sure that it's not negative? Model wraps is in the right place.
Well. Both guys would hash index B positive or negative negative.
It will be negative. Can I use an index that is negative?
No. So you have a little problem of all those numbers, there is one that is going to betray you.
If I were to return, you know, if I were to say +, yeah, because I didn't reach the extreme, the case, you know what I mean?
Guys, how would we know a little better? And you say, but then what can we do?
Well, what you can do is the following you can instead of getting you see, you just want a value, no matter which one.
So you want to say, let's just do the modulus, because by getting the modulus first,
you're going to basically get what a value that is between zero and five and four and then you get the absolute value of it.
And now both. One minute, then, when you yourself.
OK, amigos. They said maybe there's a better way to present these, maybe I'll work on something, but do you get the idea of what I'm trying to say?
The bottom line is hash code returns an integer. Is it possible for the function to return this the smallest value that you can have?
Sure, that single value is betraying you because when you compute the absolute value,
you have to compute the absolute value of the result of the modulus operation.
By doing the modulus operation first, then you're basically getting a negative value that is not as small as that one.
And then that will allow you to get the actual absolute value.
You get a positive value. Keep that in mind. OK, very good.
Now, guys, this slide is to tell you that, hey, how come they're doing all these operations here?
These are Bitwise operations, guys. They play with this.
So they look at these data and they understood this is this creates a nice distribution.
I don't even know what is going on there with the ice. So he's trying to tell you that when you use hashing,
you need to understand the data and you may come up with some rules that because you understand the data,
those are the rules that can lead to a hash code. OK.
That is the best to avoid collision at the end of the day when you want to do this to avoid collisions, amigos.
Very good. Now let's move on to using system.
Not something that you need for that you can use for the next.
So let's just cut to the Chase said it's an interfacing java,
and there are three classes that we can use to create sets that he said has set and length has set.
A set is an interface.
What you see here in red is an interface is set is a collection, a Java collection and anything that is a Java collection is editable.
Guys, if something easy terrible, that means that you can use what they for each or enhanced follow up on it.
OK, now how can we use sets?
Well, we have these three classes. The first one has said relies on hashing.
So if you use a hash set,
you better have you better be putting objects in that hash that objects that belong to a class that satisfy the Java hash code contract.
Otherwise, things are not going to work because you're relying on hashing link hash that also does the same.
Three set does not. So you wouldn't work, but you should not use classes that do not implement the actual contract.
Let's just take a look at the code. Let's go right into the code. So if we go here sets guys a set is an interface.
So I can create a set. Let me actually do this set of strings in my ear, let's say friends equals, can I create an instance of an interface?
No, but I can create a hash set.
And now I cannot elements to that said, I can say friends stood at a a, a a a Monica and friends don't add a Chandler.
OK. And now I can print OK, that and because Jesus said there is no ready, OK method that allows me to do that and now put Chandler and Monica.
And then their operations that allows me to check membership, OK, I can say if friends, the friends that contains Monica.
Then I would say since then, there are the train line. Yes.
So we should see yes. Woof. Yes. That's it.
No, and there are other methods, for example, their methods, like what is this size?
I can say system, though the the prime line. Friends size.
And I can say friends the size. Pope.
Oh, this size is too, Angus, what I can also eaterie, I can say, you know, a friend, call on friends because guess what?
It's a collection and then I can print their names and then I can have a friend.
Now proof. I have.
OK. Chandler and Monica Amigos, are we doing?
Do you like that part? We just need guys. This is so many of the big example.
You can now look at the example your own date at on. But I think this will help you to get it like, Oh, I get the idea.
Now the next question here is what's the difference between has set or you seen the other two classes?
Let me tell you what it is. First, which element did I added first, Monica or Chandler?
Monica, right? But when I displayed them, when I, for example, iterate through them, which ones show will first Chandler?
You say why Monica did not show up first? Well, nobody knows because he's using hashing.
A set. You don't care about order when it comes to a set.
I deal with it. So when you least the elements of a set that you have built with, you see how much that the order is.
Whatever internally the system is doing, you will find all the elements if we were to add more friends.
OK, Joey. Then you will see that, you know, the order varies.
You will say, Hey, well, Joey now comes up first, but the operations that you want to do on a set typically don't care about order.
It's about membership. Is this member part of this? It is not part of the set.
That's what you care about. One minute. Then when you're so look at your friends, they are upset.
You look like like a linguist, go, Oh, I.
Please, please, please be on time.
Bring pencils because last time at least one student asked the other pencil, I think that's basic when you're taking an exam.
OK, guys, please break it and please. The best way to prepare for the exam, as I always mentioned, is to practice all of you.
No questions about sex. Let's now see what's the difference with the other classes.
The first one length has set, you see six is a set, but I will preserve order, you see.
But mathematically speaking, that doesn't make sense. Are you with me? But the people from DLR said, No, actually, this is practical.
Here's an application of a link has set a waiting list for a course in a weightless you want to check, is this person part of the list or not?
There's this sense of set, but what else is important about a waitlist for a course which position you are in the waitlist?
Isn't that right? The link has that answers that question.
So now when we iterate over the set, the values will come out in the order in which they were added.
You see, it doesn't make sense from my point of view of math because a set has no idea of order.
But it's a practical thing when you're trying to solve a problem. I want to set, but I also like to keep the ordering which scenes have been added.
There you go. How are they going to get this?
And then the final one? Guess guess what answers?
It basically says, Oh, OK, I keep things sorted.
So now elements, when you eat today, they come up sorted at three.
It keeps things sorted and you see how easy sorting things.
Well. What is it? This set that I'm creating is a set of what strings does the string implements.
They compare the comparable interface. That's what is being used to sort that.
So if you want to use a tree said you need to provide a class, but I gave you food earlier.
You need to implement a class that implements the comparable interface or you need to provide a comparator,
the three said can take a comparator and use that in order to compare objects.
Amigos? I wouldn't. And that's it. This about sets.
The example that I have there, guys, is something that you can take a look at at home that explores more operations.
And but but this is the essence of it and trying this a little bit of a different approach that there is,
you know, all these official examples of these things are like the summaries, guys.
You like it. Good. Talk to me. Come on. Hello.
This is Earth, guys. Spring break is over. Spring break is over.
Yes, my son has kind of see, is it not on that?
I don't know. I don't know whether he's OK. I don't know how they keep track of the order.
Never look into the questions, guys.
Yes, he used a like patch.
Over a list like a linguist.
We yeah, because of, for example, the operations that you have here are limited, their operations are limited to a city that restricted abstraction.
So you can iterating order, but you're restricted in terms of what you can do.
So we will, if you look at this, said this, the operations that you have on it said, OK, is at at all clear containers contains all these empty.
But when you have a typical lease, what do you see that you would like to do?
Go first, go last. So yes, you got this iteration when you enter a through, but that's all that you're buying with the link with, with the leadership.
Nice questions. Now let's talk about maps. Guys, let me try if I were to go like, what?
What is in mapping in, you know, in a nutshell, well, here's let's do it like this.
Guys, we have an array. Yeah, let's suppose I have an I recall a the index is one right?
And I can say S1 equals Mike, guys.
What is the type associated with indexing of an array?
What is the type of the index integer is on the right?
What if we were to remove that restriction and we can allow for index any kind of object?
That's what a map is. A map allows you to create an association between any two objects.
Here's an example of the problem that you can solve. Let's suppose that I would like to keep track of the deserts the people like.
OK. Actually, more than that, the age of everyone. OK, we would like to say, Oh, I want to keep the age of Monica to be  of Joey to be .
A map allows you to do that. A map is an associative process where we associate a key with a value.
Let's just go right into the code. Now, in the same way that is said, OK was an interface.
A map is an interface in jail. A map is an interface and basically says, I want to associate two entities a name on an integer value.
My friends, h ages. And then there are three kind of maps and you have the same.
Process has that lead has set three said, guess what, when it comes to maps is the same deal.
You will have hash map, link, hash map and tree map.
So are going to come here. I said, OK. New hash map of a string and integer.
And now you will see, how can I add elements to it? Well, you're going to be able to say my four convenience are going to call this map.
Is that OK, guys? So that I don't have to write the look. So I'm going to say Map Dot put.
I want to say Joey Twelfth.
Now Joey has , and then I want to say, Hey, Monica.
Is twenty thirty forty six.
And now you will say, can I just print this, well, let's see what we did.
So when we run this book, you will see at the top GOP  Monica .
I created a map one minute yourself so you can talk to your friend and say, What is a map?
Go for it. Yes.
Yes. So these are like a hash function of the terms of the once again, there's no sense of order here.
We don't care about that. Are you with me? We go back because I'm using a hash map.
I don't care about water. I care about the association, but not the order of that.
OK. So if I were to add another entry, OK, I don't know the order in which they're going to come.
OK, so if I were to add Rachel. And it has to do with passion.
OK, so if we come here, you see poof.
You know, it seems to be respecting the order in which I did them, but you cannot swear by that because he's relying on Hashem.
OK. This has been the key. Now how can I check that something is part of the map?
You can use it. You can actually see string a entry in H equals map the get.
What is the age of Rachel? So, Rachel?
And now if? Oh, yes, I dropped the ball.
Sorry about that. If H OK is no, no.
Sorry. Entry not found else.
Rachel's age, yes.
And then here we can put the age. So when we run this one off.
Rachel, H. It's nine, which is correct, if now I say Rettew.
He says Saudi entry not far get allows you to get that.
OK, now another way to check whether something is part of the map.
You don't have to retrieve it. You can actually do. It contains. You can say if map that contains key, which key Rachel.
Then you can say, yeah, Rachel is here.
Rachel, here. Now when you run it, says Rachel here, how are the guys?
Go ahead. All right. Value, so the key is what drives this.
So there is there a method, for example, dot a map directly map?
Yes, map dot. For example, you can get a key, it returns, hold the keys,
and then you have one that is called values that returns all the possible values that you have.
We'll talk more about that. But yes, you can get all those values with the control that you have with a key that's very sufficient.
I need this. Give me that back, amigos. Is this making sense now?
Something is important. Look at this, guys. But for more Allison Tula Nelson bought El Nelson book or the White South Beach,
the rest of the class in French or if speaking too loud and he gets in the way of the texting, let me know.
OK, I know you can cut your hair, but it's important that you can also, OK, takes correctly.
I remember details. Now I'm evil.
I'm sorry. Don't hate me now.
So, guys, you cannot is this there is a way in which you can use the full, but you cannot iterate over months as easy as we do overall, that entries?
OK? We need to be more complex in order to do the iteration.
But that's it. Now what I want to focus now is what's the difference between the three kind of maps?
Could you guess? What's the difference? What's the difference between a hash map and a hash map?
They order. That's it. Now you will see, how can I ordered this?
This is this is one way to go over this. You can say, OK, I'm going to get all the keys.
So you can say, set the string. Actually, will the string name call a long map the.
He said. I mean, he does with the police.
My friend, please. Guys, kiss it. That means they will be what are going to go through and get the kiss the name for each one of them.
And then I can then get the values so I can.
I can then say, see standard of the Green Line.
Name plus plus mop the get name.
And now no little one. Don't go away. Wow, this is complex.
So now what's going to happen are going to then from this, we're going to see each of the entries.
So we go here and you can see Rachel, nine, Joey, , Monica for six.
That's how we ladies meet you here. So people around you can hear you, that's for sure.
Now, so how did they appear?
Well, Rachel, first, Joey, Monica, Buddhist, relying, hushing, OK, now what if we were to use, you know, maybe for yet another one I can show you?
Copy. Pete?
I just want to see them in the order. Oh, there you go.
Pete came up first in the right because Unreal Tanahashi, the order is not important.
But then if I were to turn this strong hash map to link Pashman move now, they will appear in the order in which they were at it.
And what happens if I'm using a three map? They will appear sorted.
So now when I do this, now you will see, Oh, Joey comes first.
Monica after. I'm going to keep.
One minute that when you yourself look at each other and say what, what?
Poor kid, poor kid, poor kid, passive kid, Passat, that means what's happening?